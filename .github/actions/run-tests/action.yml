name: "run-tests"
description: "Set up a Python version, cache pip, install deps and run tests producing coverage. Supports Windows cmd, PowerShell, or running inside WSL. Optional upload of coverage artifact."

inputs:
  python-version:
    description: "Python version (e.g. '3.13')"
    required: true
  requirements-file:
    description: "Requirements file to install (default: requirements-dev.txt)"
    required: false
    default: "requirements-dev.txt"
  test-args:
    description: "Additional pytest args (default: tests/ -v --maxfail=1 -n auto)"
    required: false
    default: "tests/ -v --maxfail=1 -n auto --durations=20"
  coverage-file:
    description: "Optional coverage filename (default: coverage-<version>.xml)"
    required: false
    default: ""
  windows-shell:
    description: "On Windows, which shell to use: cmd | pwsh | wsl"
    required: false
    default: "cmd"
  upload-coverage:
    description: "If 'true', upload the produced coverage xml as an artifact from this step (default: false)"
    required: false
    default: "false"

outputs:
  coverage-file:
    description: "Path to coverage xml produced."

runs:
  using: "composite"
  steps:
    - name: Prepare pip cache
      uses: ./.github/actions/pip-cache
      with:
        python-version: ${{ inputs.python-version }}
        windows-shell: ${{ inputs.windows-shell }}
        deps-files: |
          **/pyproject.toml
          **/requirements*.txt

    # For WSL we rely on the WSL-based setup to create a venv and install
    # packages inside the distro. WSL's filesystem is separate, and caching
    # that state is more complex; handle it later if needed. For now we
    # ensure native Windows pip caches are present to avoid re-downloads.

    - name: Populate WSL pip cache from host (if present)
      if: runner.os == 'Windows' && (inputs.windows-shell == 'wsl')
      shell: cmd
      run: |
        rem If the host pip cache was restored on Windows, copy it into WSL
        rem so WSL installs can reuse downloaded wheels instead of re-downloading.
        if exist "%LOCALAPPDATA%\pip\Cache" (
          for /f "delims=" %%P in ('wsl wslpath -u "%LOCALAPPDATA%\\pip\\Cache"') do set "WSLPIP=%%P"
          wsl bash -lc "mkdir -p ~/.cache/pip || true"
          wsl bash -lc "cp -r '%WSLPIP%'/* ~/.cache/pip/ || true"
        ) else (
          echo Host pip cache not present, skipping WSL cache populate
        )
    # Setup WSL with Ubuntu and deadsnakes PPA (required for Windows WSL shell)
    - name: Setup WSL with deadsnakes
      if: runner.os == 'Windows' && (inputs.windows-shell == 'wsl')
      uses: ./.github/actions/setup-wsl
      with:
        distribution: Ubuntu-24.04
        additional-packages: python3 python3-pip python3-venv

    # Install requested Python version in WSL and copy workspace to ext4 filesystem
    - name: Setup WSL Python and workspace
      if: runner.os == 'Windows' && (inputs.windows-shell == 'wsl')
      shell: cmd
      env:
        INPUT_PYTHON_VERSION: ${{ inputs.python-version }}
        INPUT_REQUIREMENTS_FILE: ${{ inputs.requirements-file }}
      run: |
        rem Install the requested Python version in WSL via deadsnakes
        wsl bash -lc "sudo apt-get install -y python%INPUT_PYTHON_VERSION% python%INPUT_PYTHON_VERSION%-venv python%INPUT_PYTHON_VERSION%-dev"

        rem Convert Windows workspace path to WSL path for copying
        for /f "delims=" %%P in ('wsl wslpath -u "%CD%"') do set "WPATH=%%P"

        rem Copy workspace to WSL ext4 filesystem (~/gitspaces) for faster I/O
        wsl bash -lc "rm -rf ~/gitspaces && mkdir -p ~/gitspaces && cp -r '%WPATH%'/. ~/gitspaces/"

        rem Create venv with the correct Python version in ext4 filesystem
        wsl bash -lc "cd ~/gitspaces && python%INPUT_PYTHON_VERSION% -m venv .venv-py%INPUT_PYTHON_VERSION%"

        rem Activate venv and install dependencies
        wsl bash -lc "cd ~/gitspaces && source .venv-py%INPUT_PYTHON_VERSION%/bin/activate && python -m pip install --upgrade pip && python -m pip install -e .[dev]"




    # Unix / macOS path (shared script)
    - name: Run tests (bash)
      if: runner.os != 'Windows'
      shell: bash
        run: |
          echo "Start test run: $(date -u +'%Y-%m-%dT%H:%M:%SZ')"
          ./scripts/ci/run-tests.sh ${{ inputs.test-args }}
          RC=$?
          echo "End test run: $(date -u +'%Y-%m-%dT%H:%M:%SZ') (exit=$RC)"
          exit $RC

    # Windows: native cmd.exe (shared script)
    - name: Run tests (cmd)
      if: runner.os == 'Windows' && (inputs.windows-shell == 'cmd')
      shell: cmd
      run: |
        rem Replace -n auto with -n 0 on Windows cmd for diagnostic stability
        set "TEST_ARGS=${{ inputs.test-args }}"
        set "TEST_ARGS=%TEST_ARGS:-n auto=-n 0%"
        echo Start test run: %DATE% %TIME%
        scripts\ci\run-tests.cmd %TEST_ARGS%
        set RC=%ERRORLEVEL%
        echo End test run: %DATE% %TIME% (exit=%RC%)
        exit /b %RC%

    # Windows: PowerShell (shared script)
    - name: Run tests (pwsh)
      if: runner.os == 'Windows' && (inputs.windows-shell == 'pwsh')
      shell: pwsh
      run: |
        # Replace -n auto with -n 0 on Windows PowerShell for diagnostic stability
        $testArgs = '${{ inputs.test-args }}' -replace '-n auto','-n 0'
        Write-Host "Start test run: $(Get-Date -Format o)"
        $sec = (Measure-Command { ./scripts/ci/run-tests.ps1 $testArgs }).TotalSeconds
        Write-Host "End test run: $(Get-Date -Format o) - Duration(s): $sec"

    # Windows: run inside WSL (invoked via wsl.exe). Uses host cmd shell to convert paths and call wsl.
    - name: Run tests on Windows (WSL)
      if: runner.os == 'Windows' && (inputs.windows-shell == 'wsl')
      id: run_win_wsl
      shell: cmd
      env:
        INPUT_COVERAGE_FILE: ${{ inputs.coverage-file }}
        INPUT_PYTHON_VERSION: ${{ inputs.python-version }}
        INPUT_TEST_ARGS: ${{ inputs.test-args }}
        VENV_PATH: ${{ steps.venv.outputs.venv-path }}
      run: |
        rem Determine coverage filename
        set "COVERAGE_FILE=%INPUT_COVERAGE_FILE%"
        if "%COVERAGE_FILE%"=="" set "COVERAGE_FILE=coverage-%INPUT_PYTHON_VERSION%.xml"

        rem Convert Windows workspace path to WSL path for coverage copy-back
        for /f "delims=" %%P in ('wsl wslpath -u "%CD%"') do set "WPATH=%%P"

        rem Run pytest inside WSL using ext4 filesystem (~/gitspaces) for best performance
        echo Start WSL pytest: %DATE% %TIME%
        wsl bash -lc "cd ~/gitspaces && source .venv-py%INPUT_PYTHON_VERSION%/bin/activate && python -m pytest %INPUT_TEST_ARGS% --cov=src/gitspaces --cov-report=xml:%COVERAGE_FILE% --cov-report=term"
        set RC=%ERRORLEVEL%
        echo End WSL pytest: %DATE% %TIME% (exit=%RC%)

        rem Copy coverage file back to Windows workspace for artifact upload
        wsl bash -lc "cp ~/gitspaces/%COVERAGE_FILE% '%WPATH%/%COVERAGE_FILE%'"

        rem Export coverage-file to GITHUB_OUTPUT for workflow consumption
        echo coverage-file=%COVERAGE_FILE%>> %GITHUB_OUTPUT%

    # Optional: upload coverage artifact from inside the composite action if requested
    - name: Upload coverage artifact (if requested)
      if: ${{ inputs.upload-coverage == 'true' }}
      uses: actions/upload-artifact@v4
      with:
        name: coverage-${{ inputs.python-version }}-${{ runner.os }}
        # try explicit coverage-file input first, otherwise default filename
        path: |
          ${{ inputs.coverage-file }}
          coverage-${{ inputs.python-version }}.xml
